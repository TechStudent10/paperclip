// --------------------------------------------------------------
// the base for the code below was generated by Claude Sonnet 4
// as much I don't like vibe-coding, there aren't many good
// timeline widgets available for Dear ImGui
// and making is kinda hard... not a valid excuse
// but the timeline works really nice from the initial impl.
// and all I need to do is modify it to my needs
// tl;dr this was mostly AI generated but hey it works
// --------------------------------------------------------------

#include "imgui_internal.h"
#include <format>
#include <fmt/base.h>
#include <fmt/format.h>
#include <widgets.hpp>
#include <imgui.h>
#include <algorithm>
#include <cmath>

#include <state.hpp>

TimelineClip::TimelineClip(int _id, const std::string& _name, float _start, float _duration, std::shared_ptr<Clip> _clip, ImU32 _color)
    : id(_id), name(_name), startTime(_start), duration(_duration), color(_color), clip(_clip), selected(false) {
}

float TimelineClip::GetEndTime() const {
    return startTime + duration;
}

TimelineTrack::TimelineTrack(int _id, const std::string& _name, float _height)
    : id(_id), name(_name), muted(false), locked(false), height(_height) {
}

VideoTimeline::VideoTimeline()
    : playheadTime(0.0f), zoomFactor(50.0f), scrollX(0.0f),
      timelineLength(300.0f), pixelsPerSecond(50.0f),
      isDragging(false), isScrubbing(false), resizeMode(RESIZE_NONE),
      isMovingBetweenTracks(false), originalTrackId(0) {
}

void VideoTimeline::setPlayheadTime(float time) {
    playheadTime = std::max(0.0f, std::min(timelineLength, time));

    float viewport_width = canvasSize.x - TRACK_HEADER_WIDTH;

    if (viewport_width <= 0) {
        return; // don't auto-scroll if no space
    }

    float playhead_pixel_pos = playheadTime * pixelsPerSecond;
    float target_scroll = playhead_pixel_pos - (viewport_width * 0.5f);

    if (target_scroll < 0) {
        scrollX = 0;
    } else {
        float max_scroll = std::max(0.0f, timelineLength * pixelsPerSecond - viewport_width);
        scrollX = std::min(target_scroll, max_scroll);
    }
}

float VideoTimeline::getPlayheadTime() const {
    return playheadTime;
}

int VideoTimeline::getTrackIndexAtPosition(float yPos, const ImVec2& canvasPos) const {
    auto& state = State::get();
    return std::min(
        static_cast<int>(state.video->getTracks().size() - 1),
        std::max((int)((yPos - canvasPos.y - RULER_HEIGHT) / 80.0f), 0)
    );
}

void VideoTimeline::setZoom(float zoom) {
    zoomFactor = std::max(MIN_ZOOM, std::min(MAX_ZOOM, zoom));
    pixelsPerSecond = zoomFactor;
}

void VideoTimeline::render() {
    ImGuiWindow* window = ImGui::GetCurrentWindow();
    if (window->SkipItems) return;

    ImGuiIO& io = ImGui::GetIO();
    ImDrawList* drawList = ImGui::GetWindowDrawList();

    auto& state = State::get();

    canvasPos = ImVec2(ImGui::GetCursorScreenPos().x, std::max(ImGui::GetCursorScreenPos().y + RULER_HEIGHT + TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f)), 0.f));
    canvasSize = ImGui::GetContentRegionAvail();
    canvasSize.y = std::max(canvasSize.y, RULER_HEIGHT + state.video->getTracks().size() * 80.0f);

    ImGui::InvisibleButton("timeline", canvasSize);
    bool isHovered = ImGui::IsItemHovered();
    bool isActive = ImGui::IsItemActive();

    if (isHovered) {
        if (io.MouseWheel != 0.0f && !io.KeyShift) {
            if (io.KeyCtrl) {
                float old_zoom = zoomFactor;
                setZoom(zoomFactor * (1.0f + io.MouseWheel * 0.1f));

                float mouse_time = (io.MousePos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX) / old_zoom;
                scrollX = mouse_time * zoomFactor - (io.MousePos.x - canvasPos.x - TRACK_HEADER_WIDTH);
            } else {
                scrollX -= io.MouseWheel * 50.0f;
            }
        }
    }

    float max_scroll = std::max(0.0f, timelineLength * pixelsPerSecond - (canvasSize.x - TRACK_HEADER_WIDTH));
    scrollX = std::max(0.0f, std::min(scrollX, max_scroll));

    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y), IM_COL32(45, 45, 48, 255));


    // ImGui::BeginChild("tracks", ImVec2(0, 0), true, ImGuiWindowFlags_HorizontalScrollbar);
    for (size_t i = state.video->getTracks().size() - 1; i >= 0; i--) {
        if (i > state.video->getTracks().size() - 1) {
            break;
        }
        ImGui::PushID(i);
        drawTrack(drawList, canvasPos, canvasSize, i, state.video->getTracks().size(), TrackType::Video);
        ImGui::PopID();
    }

    ImGui::Separator();

    for (size_t i = 0; i < state.video->audioTracks.size(); i++) {
        drawTrack(drawList, canvasPos, canvasSize, i, state.video->audioTracks.size(), TrackType::Audio);
    }
    // ImGui::EndChild();

    drawRuler(drawList, canvasPos, canvasSize);
    drawPlayhead(drawList, canvasPos, canvasSize);

    if (isPlacingClip) {
        drawList->AddLine({ hoverPos.x, 0 }, { hoverPos.x, 1000 },  IM_COL32(255, 255, 255, 255) );
    }

    handleInteractions(canvasPos, canvasSize, isHovered, isActive);
}

void VideoTimeline::drawRuler(ImDrawList* drawList, const ImVec2& canvasPos, const ImVec2& canvasSize) {
    ImVec2 ruler_pos = ImVec2(canvasPos.x + TRACK_HEADER_WIDTH, canvasPos.y - (RULER_HEIGHT + TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f))));
    ImVec2 ruler_size = ImVec2(canvasSize.x - TRACK_HEADER_WIDTH, RULER_HEIGHT);

    drawList->AddRectFilled(ruler_pos, ImVec2(ruler_pos.x + ruler_size.x, ruler_pos.y + ruler_size.y), IM_COL32(60, 60, 63, 255));

    float start_time = scrollX / pixelsPerSecond;
    float end_time = (scrollX + ruler_size.x) / pixelsPerSecond;

    float step = 1.0f;
    if (pixelsPerSecond > 100) step = 0.1f;
    else if (pixelsPerSecond < 20) step = 5.0f;

    for (float time = std::floor(start_time / step) * step; time <= end_time; time += step) {
        float x = ruler_pos.x + (time * pixelsPerSecond - scrollX);
        if (x >= ruler_pos.x && x <= ruler_pos.x + ruler_size.x) {
            bool major_tick = std::fmod(time, step * 5) < 0.001f;
            float tick_height = major_tick ? ruler_size.y * 0.8f : ruler_size.y * 0.4f;

            drawList->AddLine(ImVec2(x, ruler_pos.y + ruler_size.y - tick_height), ImVec2(x, ruler_pos.y + ruler_size.y), IM_COL32(200, 200, 200, 255));

            if (major_tick) {
                char time_str[32];
                int minutes = (int)time / 60;
                int seconds = (int)time % 60;
                int frames = (int)((time - (int)time) * State::get().video->getFPS());
                snprintf(time_str, sizeof(time_str), "%02d:%02d:%02d", minutes, seconds, frames);

                drawList->AddText(ImVec2(x + 3, ruler_pos.y + 5), IM_COL32(200, 200, 200, 255), time_str);
            }
        }
    }
}

void VideoTimeline::drawTrack(ImDrawList* drawList, const ImVec2& canvasPos, const ImVec2& canvasSize, size_t trackIndex, size_t trackListSize, TrackType type) {
    auto& state = State::get();
    float track_y = canvasPos.y + RULER_HEIGHT + (type == TrackType::Video ? trackListSize - 1 - trackIndex : trackIndex) * 60.0f + (type == TrackType::Audio ? state.video->getTracks().size() * 60 : 0);

    ImVec2 header_pos = ImVec2(canvasPos.x, track_y);
    ImVec2 header_size = ImVec2(TRACK_HEADER_WIDTH, 60.0f);

    ImVec2 content_pos = ImVec2(canvasPos.x + TRACK_HEADER_WIDTH, track_y);
    ImVec2 content_size = ImVec2(canvasSize.x - TRACK_HEADER_WIDTH, 60.0f);

    drawList->AddRectFilled(header_pos, ImVec2(header_pos.x + header_size.x, header_pos.y + header_size.y), IM_COL32(55, 55, 58, 255));
    drawList->AddRect(header_pos, ImVec2(header_pos.x + header_size.x, header_pos.y + header_size.y), IM_COL32(70, 70, 73, 255));

    drawList->AddText(ImVec2(header_pos.x + 10, header_pos.y + 10), IM_COL32(200, 200, 200, 255), fmt::format("{} {}", type == TrackType::Audio ? "Audio" : "Video", trackIndex + 1).c_str());

    ImU32 track_bg_color = (trackIndex % 2 == 0) ? IM_COL32(50, 50, 53, 255) : IM_COL32(45, 45, 48, 255);
    drawList->AddRectFilled(content_pos, ImVec2(content_pos.x + content_size.x, content_pos.y + content_size.y), track_bg_color);

    switch (type) {
        case TrackType::Audio:
            for (const auto& clip : state.video->audioTracks[trackIndex]->getClips()) {
                TimelineClip timelineClip(0, "Clip", (float)clip->startFrame / state.video->getFPS(), (float)clip->duration / state.video->getFPS(), clip, IM_COL32(100, 150, 200, 255));
                timelineClip.selected = state.draggingClip == clip;
                drawClip(drawList, timelineClip, content_pos, content_size, type);
            }
            break;
        case TrackType::Video:
            for (const auto& clip : state.video->getTracks()[trackIndex]->getClips()) {
                TimelineClip timelineClip(0, "Clip", (float)clip->startFrame / state.video->getFPS(), (float)clip->duration / state.video->getFPS(), clip, IM_COL32(100, 150, 200, 255));
                timelineClip.selected = state.draggingClip == clip;
                drawClip(drawList, timelineClip, content_pos, content_size, type);
            };
            break;
    }

    drawList->AddLine(ImVec2(content_pos.x, content_pos.y + content_size.y), ImVec2(content_pos.x + content_size.x, content_pos.y + content_size.y), IM_COL32(70, 70, 73, 255));

    ImGuiIO& io = ImGui::GetIO();
    ImVec2 mousePos = io.MousePos;
    bool hovered = mousePos.x >= content_pos.x && mousePos.x <= content_pos.x + content_size.x
        && mousePos.y >= content_pos.y && mousePos.y <= content_pos.y + content_size.y;

    if (hovered) {
        hoveredTrackIdx = trackIndex;
        hoveredTrackType = type;

        if (ImGui::IsMouseClicked(0)) {
            selectedTrackIdx = trackIndex;
            selectedTrackType = type;
        }
    }
}

void VideoTimeline::drawClip(ImDrawList* drawList, const TimelineClip& clip, const ImVec2& trackPos, const ImVec2& trackSize, TrackType type) {
    float clip_x = trackPos.x + (clip.startTime * pixelsPerSecond - scrollX);
    float clip_width = clip.duration * pixelsPerSecond;

    float clip_end_x = clip_x + clip_width;
    float track_end_x = trackPos.x + trackSize.x;

    if (clip_end_x < trackPos.x || clip_x > track_end_x) {
        return;
    }

    float visible_start_x = std::max(clip_x, trackPos.x);
    float visible_end_x = std::min(clip_end_x, track_end_x);
    float visible_width = visible_end_x - visible_start_x;

    ImVec2 clip_pos = ImVec2(visible_start_x, trackPos.y + 5);
    ImVec2 clip_size = ImVec2(visible_width, trackSize.y - 10);

    ImU32 clip_color = type == TrackType::Video ? IM_COL32(150, 200, 255, 255) : IM_COL32(100, 150, 100, 255);
    drawList->AddRectFilled(clip_pos, ImVec2(clip_pos.x + clip_size.x, clip_pos.y + clip_size.y), clip_color);

    drawList->AddRect(clip_pos, ImVec2(clip_pos.x + clip_size.x, clip_pos.y + clip_size.y), IM_COL32(255, 255, 255, 100), 0.0f, 0, 1.0f);

    ImGuiIO& io = ImGui::GetIO();
    ImVec2 mousePos = io.MousePos;

    auto& state = State::get();

    if (clip_x >= trackPos.x - 1) { // smol tolerance
        drawList->AddRectFilled(
            clip_pos,
            ImVec2(clip_pos.x + RESIZE_HANDLE_WIDTH, clip_pos.y + clip_size.y),
            IM_COL32(255, 255, 255, 150)
        );

        bool hovered = mousePos.x >= clip_pos.x && mousePos.x <= clip_pos.x + RESIZE_HANDLE_WIDTH &&
            mousePos.y >= clip_pos.y && mousePos.y <= clip_pos.y + clip_size.y;

        if (ImGui::IsMouseClicked(0) && hovered) {
            resizeMode = RESIZE_LEFT;
            resizingClip = clip.clip;
            state.draggingClip = clip.clip;
            resizingTrackIdx = selectedTrackIdx;
            resizeOriginalStart = clip.clip->startFrame;
            resizeOriginalDuration = clip.clip->duration;
        }
    }

    if (clip_end_x <= track_end_x + 1) { // smol tolerance x2
        ImVec2 right_handle_pos = ImVec2(clip_pos.x + clip_size.x - RESIZE_HANDLE_WIDTH, clip_pos.y);
        drawList->AddRectFilled(
            right_handle_pos,
            ImVec2(right_handle_pos.x + RESIZE_HANDLE_WIDTH, right_handle_pos.y + clip_size.y),
            IM_COL32(255, 255, 255, 150)
        );

        bool hovered = mousePos.x >= right_handle_pos.x && mousePos.x <= right_handle_pos.x + RESIZE_HANDLE_WIDTH &&
            mousePos.y >= right_handle_pos.y && mousePos.y <= right_handle_pos.y + clip_size.y;

        if (ImGui::IsMouseClicked(0) && hovered) {
            resizeMode = RESIZE_RIGHT;
            state.draggingClip = clip.clip;
            resizingClip = clip.clip;
            resizingTrackIdx = selectedTrackIdx;
            resizeOriginalStart = clip.clip->startFrame;
            resizeOriginalDuration = clip.clip->duration;
        }
    }

    if (resizeMode == RESIZE_NONE) {
        bool hovered = mousePos.x >= clip_pos.x && mousePos.x <= clip_pos.x + clip_end_x &&
            mousePos.y >= clip_pos.y && mousePos.y <= clip_pos.y + clip_size.y;

        if (ImGui::IsMouseClicked(0) && hovered) {
            auto& state = State::get();
            state.draggingClip = clip.clip;
            draggingTrackIdx = selectedTrackIdx;
            originalTrackId = selectedTrackIdx;
            dragOffset = ImVec2(
                (((float)clip.clip->startFrame / state.video->getFPS()) * pixelsPerSecond) - (mousePos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX),
                0
            );
            isDragging = true;
            isMovingBetweenTracks = false;
        }
    }

    if (clip_size.x > 30) {
        drawList->AddText(ImVec2(clip_pos.x + 5 + RESIZE_HANDLE_WIDTH, clip_pos.y + 5), clip.selected ? IM_COL32(230, 245, 65, 255) : IM_COL32(255, 255, 255, 255), clip.clip->m_metadata.name.c_str());
    }
}

VideoTimeline::ResizeMode VideoTimeline::GetResizeMode(const ImVec2& mouse_pos, std::shared_ptr<Clip> clip, const ImVec2& track_pos, const ImVec2& track_size, float clickTime) {
    auto state = State::get();
    float clip_x = track_pos.x + ((float)clip->startFrame / state.video->getFPS() * pixelsPerSecond - scrollX);
    float clip_width = (float)clip->duration / state.video->getFPS() * pixelsPerSecond;

    ImVec2 clip_pos = ImVec2(std::max(clip_x, track_pos.x), track_pos.y + 5);
    ImVec2 clip_size = ImVec2(std::min(clip_width, track_pos.x + track_size.x - clip_pos.x), track_size.y - 10);

    if (mouse_pos.x >= clip_pos.x && mouse_pos.x <= clip_pos.x + RESIZE_HANDLE_WIDTH) {
        return RESIZE_LEFT;
    }

    if (mouse_pos.x >= clip_pos.x + clip_size.x - RESIZE_HANDLE_WIDTH &&
        mouse_pos.x <= clip_pos.x + clip_size.x) {
        return RESIZE_RIGHT;
    }

    return RESIZE_NONE;
}

void VideoTimeline::drawPlayhead(ImDrawList* drawList, const ImVec2& canvasPos, const ImVec2& canvasSize) {
    float playhead_x = canvasPos.x + TRACK_HEADER_WIDTH + (playheadTime * pixelsPerSecond - scrollX);

    if (playhead_x >= canvasPos.x + TRACK_HEADER_WIDTH && playhead_x <= canvasPos.x + canvasSize.x) {
        drawList->AddLine(ImVec2(playhead_x, canvasPos.y + RULER_HEIGHT - (RULER_HEIGHT + TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f)))), ImVec2(playhead_x, canvasPos.y + canvasSize.y - (RULER_HEIGHT + TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f)))), IM_COL32(255, 100, 100, 255), 2.0f);

        ImVec2 handle_pos = ImVec2(playhead_x - 6, canvasPos.y + RULER_HEIGHT - 10);
        ImVec2 handle_size = ImVec2(12, 10);
        drawList->AddTriangleFilled(ImVec2(handle_pos.x, handle_pos.y - (RULER_HEIGHT + TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f)))), ImVec2(handle_pos.x + handle_size.x, handle_pos.y - (RULER_HEIGHT + TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f)))), ImVec2(handle_pos.x + handle_size.x * 0.5f, handle_pos.y + handle_size.y - (RULER_HEIGHT + TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f)))), IM_COL32(255, 100, 100, 255));
    }
}

void VideoTimeline::handleInteractions(const ImVec2& canvasPos, const ImVec2& canvasSize, bool isHovered, bool isActive) {
    ImGuiIO& io = ImGui::GetIO();
    io.MouseWheelRequestAxisSwap = false;
    auto& state = State::get();
    
    if (isHovered) {
        if (io.MouseWheel != 0.0f && !io.KeyShift) {
            fmt::println("{}", io.KeyShift);
            if (io.KeyCtrl) {
                float old_zoom = zoomFactor;
                setZoom(zoomFactor * (1.0f + io.MouseWheel * 0.1f));
                
                float mouse_time = (io.MousePos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX) / old_zoom;
                scrollX = mouse_time * zoomFactor - (io.MousePos.x - canvasPos.x - TRACK_HEADER_WIDTH);
                io.MouseWheel = 0.f;
            }
            if (io.MouseWheelH != 0.0f && !io.KeyShift) {
                scrollX -= io.MouseWheelH * 50.0f;
                io.MouseWheel = 0.f;
            }
            else if (!io.KeyCtrl && !io.KeyShift && io.MouseWheel != 0.0f) {
                scrollX -= io.MouseWheel * 50.0f;
                io.MouseWheel = 0.f;
            }
        }
        
        if (isPlacingClip) {
            hoverPos = io.MousePos;
        }
    }

    if (!ImGui::IsWindowFocused()) return;

    if (isHovered && ImGui::IsMouseClicked(0)) {
        ImVec2 mouse_pos = io.MousePos;
        dragStartPos = mouse_pos;

        // playhead
        float playhead_x = canvasPos.x + TRACK_HEADER_WIDTH + (playheadTime * pixelsPerSecond - scrollX);
        if (mouse_pos.y <= canvasPos.y - (TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f))) &&
            std::abs(mouse_pos.x - playhead_x) < 10) {
            isScrubbing = true;
        }
        // ruler (scrub to time)
        else if (mouse_pos.y <= canvasPos.y - (TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f))) && mouse_pos.x >= canvasPos.x + TRACK_HEADER_WIDTH) {
            float new_time = (mouse_pos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX) / pixelsPerSecond;
            setPlayheadTime(new_time);
            state.currentFrame = new_time * state.video->getFPS();
            isScrubbing = true;
        }
        else if (isPlacingClip && placeType == selectedTrackType) {
            float time = (mouse_pos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX) / pixelsPerSecond;
            int frame = state.video->frameForTime(time);
            bool collision = false;
            if (selectedTrackType == TrackType::Video) {
                for (auto clip : state.video->getTracks()[selectedTrackIdx]->getClips()) {
                    if (frame >= clip->startFrame && frame <= clip->startFrame + clip->duration) {
                        collision = true;
                        break;
                    }
                }
            } else if (selectedTrackType == TrackType::Audio) {
                for (auto clip : state.video->audioTracks[selectedTrackIdx]->getClips()) {
                    if (frame >= clip->startFrame && frame <= clip->startFrame + clip->duration) {
                        collision = true;
                        break;
                    }
                }
            }
            if (placeCb && !collision) {
                placeCb(frame, selectedTrackIdx);
                placeCb = nullptr;
                isPlacingClip = false;
            }
        }
    }

    if (resizeMode != RESIZE_NONE && ImGui::IsMouseDragging(0)) {
        ImVec2 mouse_pos = io.MousePos;
        float mouse_time = (mouse_pos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX) / pixelsPerSecond;
        resizingTrackIdx = std::max(0, resizingTrackIdx);

        if (resizeMode == RESIZE_LEFT) {
            float newStart = std::max(0.0f, mouse_time);
            float maxStart = (float)(resizeOriginalStart + resizeOriginalDuration) / state.video->getFPS() - 0.1f; // Min 0.1s duration
            newStart = std::min(newStart, maxStart);

            int newStartFrame = state.video->frameForTime(newStart);
            if (selectedTrackType == TrackType::Video) {
                for (auto clip : state.video->getTracks()[resizingTrackIdx]->getClips()) {
                    if (clip == resizingClip) continue;
                    int clipEnd = clip->startFrame + clip->duration; // exclusive

                    if (!(newStartFrame >= clipEnd)) {
                        newStartFrame = clipEnd + 1;
                        break;
                    }
                }
            } else {
                for (auto clip : state.video->audioTracks[resizingTrackIdx]->getClips()) {
                    if (clip == resizingClip) continue;
                    int clipEnd = clip->startFrame + clip->duration; // exclusive

                    if (!(newStartFrame >= clipEnd)) {
                        newStartFrame = clipEnd + 1;
                        break;
                    }
                }
            }
            resizingClip->startFrame = newStartFrame;
            resizingClip->duration = resizeOriginalDuration - (newStartFrame - (float)(resizeOriginalStart));
        } else if (resizeMode == RESIZE_RIGHT) {
            float minEndTime = (float)resizingClip->startFrame / state.video->getFPS() + 0.1f; // Min 0.1s duration
            float newEndTime = std::max(minEndTime, mouse_time);
            int newEndFrame = state.video->frameForTime(newEndTime);
            if (selectedTrackType == TrackType::Video) {
                for (auto clip : state.video->getTracks()[resizingTrackIdx]->getClips()) {
                    if (clip == resizingClip || clip->startFrame + clip->duration <= resizingClip->startFrame) continue;
                    int clipStart = clip->startFrame;

                    if (newEndFrame >= clipStart) {
                        newEndFrame = clipStart - 1;
                        break;
                    }
                }
            } else {
                for (auto clip : state.video->audioTracks[resizingTrackIdx]->getClips()) {
                    if (clip == resizingClip || clip->startFrame + clip->duration <= resizingClip->startFrame) continue;
                    int clipStart = clip->startFrame;

                    if (newEndFrame >= clipStart) {
                        newEndFrame = clipStart - 1;
                        break;
                    }
                }
            }
            resizingClip->duration = newEndFrame - resizingClip->startFrame;
        }
    }

    if (isDragging && resizeMode == RESIZE_NONE && ImGui::IsMouseDragging(0)) {
        if (state.draggingClip) {
            ImVec2 mouse_pos = io.MousePos;

            float vertical_movement = std::abs(mouse_pos.y - dragStartPos.y);
            if (vertical_movement > 20.0f) { // 20 pixel threshold
                isMovingBetweenTracks = true;
                ogTrackType = selectedTrackType;
            }

            int targetTrack = hoveredTrackIdx;

            float new_start_time = (mouse_pos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX + dragOffset.x) / pixelsPerSecond;
            int newStartFrame = state.video->frameForTime(std::max(0.0f, new_start_time));
            int newEndFrame = state.draggingClip->duration + newStartFrame;

            if (isMovingBetweenTracks && targetTrack != draggingTrackIdx && state.draggingClip && selectedTrackType == ogTrackType && hoveredTrackType == ogTrackType) {
                bool collision = false;
                if (selectedTrackType == TrackType::Video) {
                    for (auto clip : state.video->getTracks()[targetTrack]->getClips()) {
                        if (clip == state.draggingClip) continue;
                        int clipStart = clip->startFrame;
                        int clipEnd = clip->startFrame + clip->duration; // exclusive

                        if (!(newEndFrame <= clipStart || newStartFrame >= clipEnd)) {
                            collision = true;
                            break;
                        }

                        if (collision) {
                            break;
                        }
                    }
                } else {
                    for (auto clip : state.video->audioTracks[targetTrack]->getClips()) {
                        if (clip == state.draggingClip) continue;
                        int clipStart = clip->startFrame;
                        int clipEnd = clip->startFrame + clip->duration; // exclusive

                        if (!(newEndFrame <= clipStart || newStartFrame >= clipEnd)) {
                            collision = true;
                            break;
                        }

                        if (collision) {
                            break;
                        }
                    }
                }
                if (!collision) {
                    if (selectedTrackType == TrackType::Audio) {
                        state.video->audioTracks[targetTrack]->addClip(std::dynamic_pointer_cast<AudioClip>(state.draggingClip));
                        state.video->audioTracks[draggingTrackIdx]->removeClip(std::dynamic_pointer_cast<AudioClip>(state.draggingClip));
                    } else {
                        state.video->getTracks()[targetTrack]->addClip(state.draggingClip);
                        state.video->getTracks()[draggingTrackIdx]->removeClip(state.draggingClip);
                    }
                    draggingTrackIdx = targetTrack;
                }
            }

            // check if it collides with another clip
            bool collision = false;
            if (selectedTrackType == TrackType::Video) {
                for (auto clip : state.video->getTracks()[draggingTrackIdx]->getClips()) {
                    if (clip == state.draggingClip) continue;
                    int clipStart = clip->startFrame;
                    int clipEnd = clip->startFrame + clip->duration; // exclusive

                    if (!(newEndFrame <= clipStart || newStartFrame >= clipEnd)) {
                        collision = true;
                        break;
                    }

                    if (collision) {
                        break;
                    }
                }
            } else {
                for (auto clip : state.video->audioTracks[draggingTrackIdx]->getClips()) {
                    if (clip == state.draggingClip) continue;
                    int clipStart = clip->startFrame;
                    int clipEnd = clip->startFrame + clip->duration; // exclusive

                    if (!(newEndFrame <= clipStart || newStartFrame >= clipEnd)) {
                        collision = true;
                        break;
                    }

                    if (collision) {
                        break;
                    }
                }
            }
            if (!collision) {
                state.draggingClip->startFrame = newStartFrame;
            }
        }
    }

    if (isScrubbing && ImGui::IsMouseDragging(0)) {
        float new_time = (io.MousePos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX) / pixelsPerSecond;
        setPlayheadTime(new_time);
        state.currentFrame = new_time * state.video->getFPS();
    }

    state.video->recalculateFrameCount();
    state.currentFrame = std::max(0, state.currentFrame);
    state.currentFrame = std::min(state.currentFrame, state.video->frameCount);

    if (ImGui::IsMouseReleased(0)) {
        isDragging = false;
        isScrubbing = false;
        isMovingBetweenTracks = false;
        resizingClip = nullptr;
        draggingTrackIdx = -1;
        originalTrackId = -1;
        resizeMode = RESIZE_NONE;
        // state.draggingClip = nullptr;
    }
}

void VideoTimeline::scrollToTime(float time, bool center) {
    float target_pixel_pos = time * pixelsPerSecond;
    float viewport_width = canvasSize.x - TRACK_HEADER_WIDTH;

    if (center) {
        scrollX = target_pixel_pos - viewport_width * 0.5f;
    } else {
        scrollX = target_pixel_pos;
    }

    // Clamp scroll
    float max_scroll = std::max(0.0f, timelineLength * pixelsPerSecond - viewport_width);
    scrollX = std::max(0.0f, std::min(scrollX, max_scroll));
}
