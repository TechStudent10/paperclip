// --------------------------------------------------------------
// the base for the code below was generated by Claude Sonnet 4
// as much I don't like vibe-coding, there aren't many good
// timeline widgets available for Dear ImGui
// and making is kinda hard... not a valid excuse
// but the timeline works really nice from the initial impl.
// and all I need to do is modify it to my needs
// tl;dr this was mostly AI generated but hey it works
// update: most of this has been updated and is not AI generated
// so like
// ¯\_(ツ)_/¯
// --------------------------------------------------------------

#include <glad/include/glad/gl.h>

#include <imgui_internal.h>
#include <fmt/base.h>
#include <fmt/format.h>
#include <widgets.hpp>
#include <imgui.h>
#include <algorithm>
#include <cmath>

#include <state.hpp>

#include <action/actions/MoveClip.hpp>
#include <action/actions/ResizeClip.hpp>
#include <action/actions/ChangeClipTrack.hpp>

#include <clips/properties/number.hpp>

TimelineClip::TimelineClip(int _id, const std::string& _name, float _start, float _duration, std::shared_ptr<Clip> _clip, ImU32 _color)
    : id(_id), name(_name), startTime(_start), duration(_duration), color(_color), clip(_clip), selected(false) {
}

float TimelineClip::GetEndTime() const {
    return startTime + duration;
}

TimelineTrack::TimelineTrack(int _id, const std::string& _name, float _height)
    : id(_id), name(_name), muted(false), locked(false), height(_height) {
}

Timeline::Timeline()
    : zoomFactor(50.0f), scrollX(0.0f),
      timelineLength(300.0f), pixelsPerSecond(50.0f),
      isDragging(false), isScrubbing(false), resizeMode(RESIZE_NONE),
      isMovingBetweenTracks(false), originalTrackId(0) {
}

void Timeline::autoScroll() {
    if (!State::get().isPlaying) return;

    float viewport_width = canvasSize.x - TRACK_HEADER_WIDTH;

    if (viewport_width <= 0) {
        return; // don't auto-scroll if no space
    }

    float playhead_pixel_pos = getPlayheadTime() * pixelsPerSecond;
    float target_scroll = playhead_pixel_pos - (viewport_width * 0.5f);

    if (target_scroll < 0) {
        scrollX = 0;
    } else {
        float max_scroll = std::max(0.0f, timelineLength * pixelsPerSecond - viewport_width);
        scrollX = std::min(target_scroll, max_scroll);
    }
}

float Timeline::getPlayheadTime() const {
    auto& state = State::get();
    return state.video->timeForFrame(state.currentFrame);
}

int Timeline::getTrackIndexAtPosition(float yPos, const ImVec2& canvasPos) const {
    auto& state = State::get();
    return std::min(
        static_cast<int>(state.video->getTracks().size() - 1),
        std::max((int)((yPos - canvasPos.y - RULER_HEIGHT) / 80.0f), 0)
    );
}

void Timeline::setZoom(float zoom) {
    zoomFactor = std::max(MIN_ZOOM, std::min(MAX_ZOOM, zoom));
    pixelsPerSecond = zoomFactor;
}

void Timeline::render() {
    ImGuiWindow* window = ImGui::GetCurrentWindow();
    if (window->SkipItems) return;

    ImGuiIO& io = ImGui::GetIO();
    ImDrawList* drawList = ImGui::GetWindowDrawList();

    auto& state = State::get();

    canvasPos = ImVec2(ImGui::GetCursorScreenPos().x, std::max(ImGui::GetCursorScreenPos().y + RULER_HEIGHT + TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f)), 0.f));
    canvasSize = ImGui::GetContentRegionAvail();
    canvasSize.y = std::max(canvasSize.y, RULER_HEIGHT + state.video->getTracks().size() * 80.0f);

    ImGui::InvisibleButton("timeline", canvasSize);
    bool isHovered = ImGui::IsItemHovered();
    bool isActive = ImGui::IsItemActive();

    autoScroll();

    if (isHovered) {
        if (io.MouseWheel != 0.0f && !io.KeyShift) {
            if (io.KeyCtrl) {
                float old_zoom = zoomFactor;
                setZoom(zoomFactor * (1.0f + io.MouseWheel * 0.1f));

                float mouse_time = (io.MousePos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX) / old_zoom;
                scrollX = mouse_time * zoomFactor - (io.MousePos.x - canvasPos.x - TRACK_HEADER_WIDTH);
            } else {
                scrollX -= io.MouseWheel * 50.0f;
            }
        }
    }

    float max_scroll = std::max(0.0f, timelineLength * pixelsPerSecond - (canvasSize.x - TRACK_HEADER_WIDTH));
    scrollX = std::max(0.0f, std::min(scrollX, max_scroll));

    drawList->AddRectFilled(canvasPos, ImVec2(canvasPos.x + canvasSize.x, canvasPos.y + canvasSize.y), IM_COL32(45, 45, 48, 255));


    // ImGui::BeginChild("tracks", ImVec2(0, 0), true, ImGuiWindowFlags_HorizontalScrollbar);
    for (size_t i = state.video->getTracks().size() - 1; i >= 0; i--) {
        if (i > state.video->getTracks().size() - 1) {
            break;
        }
        ImGui::PushID(i);
        drawTrack(drawList, canvasPos, canvasSize, i, state.video->getTracks().size(), TrackType::Video);
        ImGui::PopID();
    }

    ImGui::Separator();

    for (size_t i = 0; i < state.video->audioTracks.size(); i++) {
        drawTrack(drawList, canvasPos, canvasSize, i, state.video->audioTracks.size(), TrackType::Audio);
    }
    // ImGui::EndChild();

    drawRuler(drawList, canvasPos, canvasSize);
    drawPlayhead(drawList, canvasPos, canvasSize);

    if (isPlacingClip) {
        drawList->AddLine({ hoverPos.x, 0 }, { hoverPos.x, 1000 },  IM_COL32(255, 255, 255, 255) );
    }

    handleInteractions(canvasPos, canvasSize, isHovered, isActive);
}

void Timeline::drawRuler(ImDrawList* drawList, const ImVec2& canvasPos, const ImVec2& canvasSize) {
    ImVec2 ruler_pos = ImVec2(canvasPos.x + TRACK_HEADER_WIDTH, canvasPos.y - (RULER_HEIGHT + TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f))));
    ImVec2 ruler_size = ImVec2(canvasSize.x - TRACK_HEADER_WIDTH, RULER_HEIGHT);

    drawList->AddRectFilled(ruler_pos, ImVec2(ruler_pos.x + ruler_size.x, ruler_pos.y + ruler_size.y), IM_COL32(60, 60, 63, 255));

    float start_time = scrollX / pixelsPerSecond;
    float end_time = (scrollX + ruler_size.x) / pixelsPerSecond;

    float step = 1.0f;
    if (pixelsPerSecond > 100) step = 0.1f;
    else if (pixelsPerSecond < 20) step = 5.0f;

    for (float time = std::floor(start_time / step) * step; time <= end_time; time += step) {
        float x = ruler_pos.x + (time * pixelsPerSecond - scrollX);
        if (x >= ruler_pos.x && x <= ruler_pos.x + ruler_size.x) {
            bool major_tick = std::fmod(time, step * 5) < 0.001f;
            float tick_height = major_tick ? ruler_size.y * 0.8f : ruler_size.y * 0.4f;

            drawList->AddLine(ImVec2(x, ruler_pos.y + ruler_size.y - tick_height), ImVec2(x, ruler_pos.y + ruler_size.y), IM_COL32(200, 200, 200, 255));

            if (major_tick) {
                char time_str[32];
                int minutes = (int)time / 60;
                int seconds = (int)time % 60;
                int frames = (int)((time - (int)time) * State::get().video->getFPS());
                snprintf(time_str, sizeof(time_str), "%02d:%02d:%02d", minutes, seconds, frames);

                drawList->AddText(ImVec2(x + 3, ruler_pos.y + 5), IM_COL32(200, 200, 200, 255), time_str);
            }
        }
    }
}

void Timeline::drawTrack(ImDrawList* drawList, const ImVec2& canvasPos, const ImVec2& canvasSize, size_t trackIndex, size_t trackListSize, TrackType type) {
    auto& state = State::get();

    float track_y = canvasPos.y + RULER_HEIGHT +
        (type == TrackType::Video ? trackListSize - 1 - trackIndex : trackIndex) * (CLIP_HEIGHT + 1) +
        (type == TrackType::Video ? 0 : state.video->getTracks().size() * (CLIP_HEIGHT + 1));

    ImVec2 header_pos = ImVec2(canvasPos.x, track_y);
    ImVec2 header_size = ImVec2(TRACK_HEADER_WIDTH, CLIP_HEIGHT);

    ImVec2 content_pos = ImVec2(canvasPos.x + TRACK_HEADER_WIDTH, track_y);
    ImVec2 content_size = ImVec2(canvasSize.x - TRACK_HEADER_WIDTH, CLIP_HEIGHT);

    bool trackSelected = trackIndex == selectedTrackIdx && type == selectedTrackType;
    int rg = trackSelected ? 70 : 55;

    ImU32 track_bg_color = trackSelected ? IM_COL32(50, 50, 53, 255) : IM_COL32(45, 45, 48, 255);
    drawList->AddRectFilled(content_pos, ImVec2(content_pos.x + content_size.x, content_pos.y + content_size.y), track_bg_color);

    switch (type) {
        case TrackType::Audio:
            for (const auto& _clip : state.video->audioTracks[trackIndex]->getClips()) {
                auto clip = _clip.second;
                TimelineClip timelineClip(0, "Clip", (float)clip->startFrame / state.video->getFPS(), (float)clip->duration / state.video->getFPS(), clip, IM_COL32(100, 150, 200, 255));
                timelineClip.selected = state.isClipSelected(clip);
                drawClip(drawList, timelineClip, content_pos, content_size, type);
            }
            break;
        case TrackType::Video:
            for (const auto& _clip : state.video->getTracks()[trackIndex]->getClips()) {
                auto clip = _clip.second;
                TimelineClip timelineClip(0, "Clip", (float)clip->startFrame / state.video->getFPS(), (float)clip->duration / state.video->getFPS(), clip, IM_COL32(100, 150, 200, 255));
                timelineClip.selected = state.isClipSelected(clip);
                drawClip(drawList, timelineClip, content_pos, content_size, type);
            };
            break;
    }

    drawList->AddRectFilled(header_pos, ImVec2(header_pos.x + header_size.x, header_pos.y + header_size.y), IM_COL32(rg, rg, rg + 3, 255));
    drawList->AddRect(header_pos, ImVec2(header_pos.x + header_size.x, header_pos.y + header_size.y), IM_COL32(rg + 15, rg + 15, rg + 18, 255));

    drawList->AddText(ImVec2(header_pos.x + 10, header_pos.y + 10), IM_COL32(200, 200, 200, 255), fmt::format("{} {}", type == TrackType::Audio ? "Audio" : "Video", trackIndex + 1).c_str());

    drawList->AddLine(ImVec2(content_pos.x, content_pos.y + content_size.y), ImVec2(content_pos.x + content_size.x, content_pos.y + content_size.y), IM_COL32(70, 70, 73, 255));

    ImGuiIO& io = ImGui::GetIO();
    ImVec2 mousePos = io.MousePos;
    bool hovered = mousePos.x >= content_pos.x && mousePos.x <= content_pos.x + content_size.x
        && mousePos.y >= content_pos.y && mousePos.y <= content_pos.y + content_size.y;

    if (hovered) {
        hoveredTrackIdx = trackIndex;
        hoveredTrackType = type;

        if (ImGui::IsMouseClicked(0) && ImGui::IsWindowFocused() && !isMovingBetweenTracks) {
            selectedTrackIdx = trackIndex;
            selectedTrackType = type;
        }
    }
}

void Timeline::drawClip(ImDrawList* drawList, const TimelineClip& clip, const ImVec2& trackPos, const ImVec2& trackSize, TrackType type) {
    float clipX = trackPos.x + (clip.startTime * pixelsPerSecond - scrollX);
    float clipWidth = clip.duration * pixelsPerSecond;

    float clipEndX = clipX + clipWidth;
    float trackEndX = trackPos.x + trackSize.x;

    if (clipEndX < trackPos.x || clipX > trackEndX) {
        return;
    }

    float visibleStartX = std::max(clipX, trackPos.x);
    float visibleEndX = std::min(clipEndX, trackEndX);
    float visibleWidth = visibleEndX - visibleStartX;

    bool leftHandleVisible = clipX >= trackPos.x - 1;
    bool rightHandleVisible = clipEndX <= trackEndX + 1;

    ImVec2 clipPos = ImVec2(visibleStartX, trackPos.y + 5);
    ImVec2 clipSize = ImVec2(visibleWidth, trackSize.y - 10);

    ImU32 clipColor = type == TrackType::Video ? IM_COL32(150, 200, 255, 255) : IM_COL32(100, 150, 100, 255);
    drawList->AddRectFilled(clipPos, ImVec2(clipPos.x + clipSize.x, clipPos.y + clipSize.y), clipColor);

    ImU32 darkenedCol = type == TrackType::Video ? IM_COL32(130, 180, 235, 255) : IM_COL32(80, 130, 80, 255);
    drawList->AddRectFilled(
        ImVec2(clipPos.x + (leftHandleVisible ? RESIZE_HANDLE_WIDTH : 0), clipPos.y + clipSize.y - 25),
        ImVec2(clipPos.x + clipSize.x - (rightHandleVisible ? RESIZE_HANDLE_WIDTH : 0), clipPos.y + clipSize.y),
        darkenedCol
    );

    auto previewHeight = CLIP_HEIGHT - 35.f;
    auto previewSize = clip.clip->getPreviewSize();
    auto scale = previewHeight / previewSize.y;
    auto width = (previewSize.x * scale);
    
    auto& state = State::get();

    if (clip.clip->getType() != ClipType::Audio) {
        for (int x = 0; x < (clipWidth - (rightHandleVisible ? RESIZE_HANDLE_WIDTH : 0)); x++) {        
            if ((int)x % (int)width != 0) continue;
            
            auto frame = state.video->frameForTime((x) / pixelsPerSecond);
            
            float imgStartX = clipX + RESIZE_HANDLE_WIDTH + x;
            if (imgStartX < 0 || imgStartX > (clipX + visibleWidth + scrollX)) continue;
            float imgEndX = imgStartX + width;

            float cropAmount = (std::min(imgEndX, clipPos.x + clipSize.x - (rightHandleVisible ? RESIZE_HANDLE_WIDTH : 0)) - imgStartX) / width;

            ImVec2 uv0 = ImVec2(0.0f, 0.0f);
            ImVec2 uv1 = ImVec2(cropAmount, 1.0f);

            drawList->AddImage(
                (ImTextureID)(intptr_t)clip.clip->getPreviewTexture(frame),
                ImVec2(imgStartX, clipPos.y),
                ImVec2(std::min(imgStartX + width, clipPos.x + clipSize.x - (rightHandleVisible ? RESIZE_HANDLE_WIDTH : 0)), clipPos.y + previewHeight),
                uv0,
                uv1
            );            
        }
    } else {
        auto audioClip = std::static_pointer_cast<AudioClip>(clip.clip);
        auto pixelsPerMs = pixelsPerSecond / 1000.f;

        for (int i = 0; i < clipWidth; i++) {
            auto ms = (i) / pixelsPerMs;
            if (ms >= audioClip->waveform.size()) continue;
            double amplitude = audioClip->waveform[ms];
            auto x = (clipX + RESIZE_HANDLE_WIDTH + i);
            if (x < 0 || x > (clipX + visibleWidth + scrollX)) continue;
            drawList->AddLine(
                ImVec2(x, clipPos.y + previewHeight),
                ImVec2(x, clipPos.y + previewHeight - (std::min(amplitude * (audioClip->getProperty<NumberProperty>("volume").unwrap()->data) / 100.f, 1.0) * previewHeight)),
                IM_COL32(255, 255, 255, 255)
            );
        }
    }

    drawList->AddRect(clipPos, ImVec2(clipPos.x + clipSize.x, clipPos.y + clipSize.y), IM_COL32(255, 255, 255, 100), 0.0f, 0, 1.0f);

    ImGuiIO& io = ImGui::GetIO();
    ImVec2 mousePos = io.MousePos;

    if (leftHandleVisible) { // smol tolerance
        drawList->AddRectFilled(
            clipPos,
            ImVec2(clipPos.x + RESIZE_HANDLE_WIDTH, clipPos.y + clipSize.y),
            IM_COL32(255, 255, 255, 150)
        );

        bool hovered = mousePos.x >= clipPos.x && mousePos.x <= clipPos.x + RESIZE_HANDLE_WIDTH &&
            mousePos.y >= clipPos.y && mousePos.y <= clipPos.y + clipSize.y;

        if (ImGui::IsMouseClicked(0) && hovered) {
            resizeMode = RESIZE_LEFT;
            resizingClip = clip.clip;
            state.selectClip(clip.clip);
            resizingTrackIdx = selectedTrackIdx;
            resizeOriginalStart = clip.clip->startFrame;
            resizeOriginalDuration = clip.clip->duration;
        }
    }

    if (rightHandleVisible) { // smol tolerance x2
        ImVec2 right_handle_pos = ImVec2(clipPos.x + clipSize.x - RESIZE_HANDLE_WIDTH, clipPos.y);
        drawList->AddRectFilled(
            right_handle_pos,
            ImVec2(right_handle_pos.x + RESIZE_HANDLE_WIDTH, right_handle_pos.y + clipSize.y),
            IM_COL32(255, 255, 255, 150)
        );

        bool hovered = mousePos.x >= right_handle_pos.x && mousePos.x <= right_handle_pos.x + RESIZE_HANDLE_WIDTH &&
            mousePos.y >= right_handle_pos.y && mousePos.y <= right_handle_pos.y + clipSize.y;

        if (ImGui::IsMouseClicked(0) && hovered) {
            resizeMode = RESIZE_RIGHT;
            state.selectClip(clip.clip);
            resizingClip = clip.clip;
            resizingTrackIdx = selectedTrackIdx;
            resizeOriginalStart = clip.clip->startFrame;
            resizeOriginalDuration = clip.clip->duration;
        }
    }

    bool clipHovered = mousePos.x >= clipPos.x && mousePos.x <= clipPos.x + clipSize.x &&
        mousePos.y >= clipPos.y && mousePos.y <= clipPos.y + clipSize.y;

    if (resizeMode == RESIZE_NONE) {
        if (ImGui::IsMouseClicked(0) && clipHovered && !isPlacingClip) {
            auto& state = State::get();
            auto id = clip.clip->uID;
            if (!io.KeyShift && !state.isClipSelected(clip.clip)) {
                state.deselect();
            }
            state.selectClip(id);
            originalTrackId = selectedTrackIdx;
            isDragging = true;
            isMovingBetweenTracks = false;
            initialStartFrame = clip.clip->startFrame;
            
            dragOffset = ImVec2(
                (state.video->timeForFrame(clip.clip->startFrame) * pixelsPerSecond) - (mousePos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX),
                0
            );
        }
    }

    clipHovered = clipHovered || (state.isClipSelected(clip.clip) && (resizeMode != RESIZE_NONE || isAdjustingFade || isDragging));

    const float topY = clipPos.y - 10;

    auto addRect = [drawList](const ImVec2& pos, const ImVec2& size, const ImU32& col, const ImU32& borderCol, float rounding, float thickness) {
        drawList->AddRectFilled(
            pos, ImVec2(
                pos.x + size.x,
                pos.y + size.y
            ),
            col,
            rounding
        );

        drawList->AddRect(
            pos, ImVec2(
                pos.x + size.x,
                pos.y + size.y
            ),
            borderCol,
            rounding,
            0,
            thickness
        );
    };

    // fade in
    auto fadeInPos = ImVec2(
        state.video->timeForFrame(clip.clip->fadeInFrame) * pixelsPerSecond + clipX,
        topY
    );
    auto fadeInSize = ImVec2(
        RESIZE_HANDLE_WIDTH,
        25.f
    );

    if (clipHovered) {
        addRect(
            fadeInPos,
            fadeInSize,
            IM_COL32(255, 255, 255, 255),
            IM_COL32(0, 0, 0, 255),
            3.5f,
            2.f
        );

        if (ImGui::IsMouseClicked(ImGuiMouseButton_Left) &&
            mousePos.x >= fadeInPos.x && mousePos.x <= fadeInPos.x + fadeInSize.x &&
            mousePos.y >= fadeInPos.y && mousePos.y <= fadeInPos.y + fadeInSize.y
        ) {
            isAdjustingFade = true;
            fadeAdjustID = clip.clip->uID;
            fadeDragMode = FadeDragMode::In;
        }
    }

    if (clip.clip->fadeInFrame != 0) {
        drawList->AddTriangleFilled(
            ImVec2(clipX, clipPos.y),
            ImVec2(clipX + (clip.clip->fadeInFrame * 1.f / state.video->getFPS() * pixelsPerSecond), clipPos.y),
            ImVec2(clipX, clipPos.y + previewHeight),
            IM_COL32(0, 0, 0, 125)
        );
    }

    // fade out
    auto fadeOutPos = ImVec2(
        state.video->timeForFrame(clip.clip->duration - clip.clip->fadeOutFrame) * pixelsPerSecond + clipX - RESIZE_HANDLE_WIDTH,
        topY
    );
    auto fadeOutSize = ImVec2(
        RESIZE_HANDLE_WIDTH,
        25.f
    );

    if (clipHovered) {
        addRect(
            fadeOutPos,
            fadeOutSize,
            IM_COL32(255, 255, 255, 255),
            IM_COL32(0, 0, 0, 255),
            3.5f,
            2.f
        );

        if (ImGui::IsMouseClicked(ImGuiMouseButton_Left) &&
            mousePos.x >= fadeOutPos.x && mousePos.x <= fadeOutPos.x + fadeOutSize.x &&
            mousePos.y >= fadeOutPos.y && mousePos.y <= fadeOutPos.y + fadeOutSize.y
        ) {
            isAdjustingFade = true;
            fadeAdjustID = clip.clip->uID;
            fadeDragMode = FadeDragMode::Out;
        }
    }

    if (clip.clip->fadeOutFrame != 0) {
        drawList->AddTriangleFilled(
            ImVec2(clipX + clipWidth, clipPos.y),
            ImVec2(clipX + clipWidth - (clip.clip->fadeOutFrame * 1.f / state.video->getFPS() * pixelsPerSecond), clipPos.y),
            ImVec2(clipX + clipWidth, clipPos.y + previewHeight),
            IM_COL32(0, 0, 0, 125)
        );
    }

    if (isAdjustingFade && clip.clip->uID == fadeAdjustID && ImGui::IsMouseDragging(ImGuiMouseButton_Left)) {
        switch (fadeDragMode) {
            case FadeDragMode::In:
                clip.clip->fadeInFrame += state.video->frameForTime(io.MouseDelta.x / pixelsPerSecond);
                clip.clip->fadeInFrame = std::clamp(clip.clip->fadeInFrame, 0, clip.clip->duration);
                break;
            case FadeDragMode::Out:
                clip.clip->fadeOutFrame -= state.video->frameForTime(io.MouseDelta.x / pixelsPerSecond);
                clip.clip->fadeOutFrame = std::clamp(clip.clip->fadeOutFrame, 0, clip.clip->duration);
                break;
        }
    }

    auto textSize = ImGui::CalcTextSize(clip.clip->m_metadata.name.c_str());
    auto font = io.FontDefault;
    auto size = ImGui::GetFontSize();
    if (clipSize.x < textSize.x + 30) {
        size = std::max(size * (clipSize.x / (textSize.x + 30)), 0.f);
    }

    if (size > 0 && clipSize.x > size + 10) {
        drawList->AddText(
            font,
            std::max(size, 0.1f),
            ImVec2(clipPos.x + 5 + (leftHandleVisible ? RESIZE_HANDLE_WIDTH : 0), clipPos.y + clipSize.y - 25),
            clip.selected ?
                IM_COL32(230, 245, 65, 255) :
                IM_COL32(255, 255, 255, 255),
            clip.clip->m_metadata.name.c_str()
        );
    }
}

Timeline::ResizeMode Timeline::GetResizeMode(const ImVec2& mouse_pos, std::shared_ptr<Clip> clip, const ImVec2& track_pos, const ImVec2& track_size, float clickTime) {
    auto state = State::get();
    float clip_x = track_pos.x + ((float)clip->startFrame / state.video->getFPS() * pixelsPerSecond - scrollX);
    float clip_width = (float)clip->duration / state.video->getFPS() * pixelsPerSecond;

    ImVec2 clip_pos = ImVec2(std::max(clip_x, track_pos.x), track_pos.y + 5);
    ImVec2 clip_size = ImVec2(std::min(clip_width, track_pos.x + track_size.x - clip_pos.x), track_size.y - 10);

    if (mouse_pos.x >= clip_pos.x && mouse_pos.x <= clip_pos.x + RESIZE_HANDLE_WIDTH) {
        return RESIZE_LEFT;
    }

    if (mouse_pos.x >= clip_pos.x + clip_size.x - RESIZE_HANDLE_WIDTH &&
        mouse_pos.x <= clip_pos.x + clip_size.x) {
        return RESIZE_RIGHT;
    }

    return RESIZE_NONE;
}

void Timeline::drawPlayhead(ImDrawList* drawList, const ImVec2& canvasPos, const ImVec2& canvasSize) {
    float playhead_x = canvasPos.x + TRACK_HEADER_WIDTH + (getPlayheadTime() * pixelsPerSecond - scrollX);

    if (playhead_x >= canvasPos.x + TRACK_HEADER_WIDTH && playhead_x <= canvasPos.x + canvasSize.x) {
        drawList->AddLine(
            ImVec2(
                playhead_x,
                canvasPos.y + RULER_HEIGHT -
                (
                    RULER_HEIGHT + TRACK_HEADER_WIDTH +
                    (60.f * std::min(trackScrollY, -2.2f))
                )
            ),
            ImVec2(
                playhead_x,
                canvasPos.y + canvasSize.y -
                (
                    RULER_HEIGHT + TRACK_HEADER_WIDTH +
                    (60.f * std::min(trackScrollY, -2.2f))
                )
            ),
            IM_COL32(255, 100, 100, 255),
            2.0f
        );

        ImVec2 handle_pos = ImVec2(playhead_x - 6, canvasPos.y + RULER_HEIGHT - 10);
        ImVec2 handle_size = ImVec2(12, 10);
        drawList->AddTriangleFilled(ImVec2(handle_pos.x, handle_pos.y - (RULER_HEIGHT + TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f)))), ImVec2(handle_pos.x + handle_size.x, handle_pos.y - (RULER_HEIGHT + TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f)))), ImVec2(handle_pos.x + handle_size.x * 0.5f, handle_pos.y + handle_size.y - (RULER_HEIGHT + TRACK_HEADER_WIDTH + (60.f * std::min(trackScrollY, -2.2f)))), IM_COL32(255, 100, 100, 255));
    }
}

bool Timeline::willClipCollide(int frame, int duration, int trackIdx, TrackType type, std::vector<std::string> exclusionList) {
    auto state = State::get();
    bool collision = false;
    int endFrame = frame + duration;
    auto doTheThing = [&](std::shared_ptr<Clip> clip) {
        if (utils::vectorContains(exclusionList, clip->uID)) return;

        int clipStart = clip->startFrame;
        int clipEnd = clip->startFrame + clip->duration;

        if (frame <= 0) {
            collision = true;
        }

        if (!(endFrame <= clipStart || frame >= clipEnd)) {
            collision = true;
        }
    };

    if (type == TrackType::Video) {
        for (auto _clip : state.video->getTracks()[trackIdx]->getClips()) {
            doTheThing(_clip.second);
            if (collision) break;
        }
    } else if (type == TrackType::Audio) {
        for (auto _clip : state.video->audioTracks[trackIdx]->getClips()) {
            doTheThing(_clip.second);
            if (collision) break;
        }
    }
    return collision;
}

bool Timeline::willClipCollide(float seconds, float duration, int trackIdx, TrackType type, std::vector<std::string> exclusionList) {
    auto& state = State::get();
    return willClipCollide(state.video->frameForTime(seconds), state.video->frameForTime(duration), trackIdx, type, exclusionList);
}

void Timeline::handleInteractions(const ImVec2& canvasPos, const ImVec2& canvasSize, bool isHovered, bool isActive) {
    ImGuiIO& io = ImGui::GetIO();
    io.MouseWheelRequestAxisSwap = false;
    auto& state = State::get();
    
    if (isHovered) {
        if (io.MouseWheelH != 0.0f && !io.KeyShift) {
            // fmt::println("{}", io.MouseWheelH);
            if (io.KeyCtrl) {
                float old_zoom = zoomFactor;
                setZoom(zoomFactor * (1.0f + io.MouseWheel * 0.1f));
                
                float mouse_time = (io.MousePos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX) / old_zoom;
                scrollX = mouse_time * zoomFactor - (io.MousePos.x - canvasPos.x - TRACK_HEADER_WIDTH);
                io.MouseWheel = 0.f;
            }
            if (io.MouseWheelH != 0.0f && !io.KeyShift) {
                scrollX -= io.MouseWheelH * 50.0f;
                io.MouseWheel = 0.f;
            }
            else if (!io.KeyCtrl && !io.KeyShift && io.MouseWheel != 0.0f) {
                scrollX -= io.MouseWheel * 50.0f;
                io.MouseWheel = 0.f;
            }
        }
        
        if (isPlacingClip) {
            hoverPos = io.MousePos;
        }
    }

    if (!ImGui::IsWindowFocused()) return;

    if (isHovered && ImGui::IsMouseClicked(0)) {
        ImVec2 mouse_pos = io.MousePos;
        dragStartPos = mouse_pos;

        // playhead
        float playhead_x = canvasPos.x + TRACK_HEADER_WIDTH + (getPlayheadTime() * pixelsPerSecond - scrollX);
        if (mouse_pos.y <= canvasPos.y - (TRACK_HEADER_WIDTH + (CLIP_HEIGHT * std::min(trackScrollY, -2.2f))) &&
            std::abs(mouse_pos.x - playhead_x) < 10) {
            isScrubbing = true;
        }
        // ruler (scrub to time)
        else if (mouse_pos.y <= canvasPos.y - (TRACK_HEADER_WIDTH + (CLIP_HEIGHT * std::min(trackScrollY, -2.2f))) && mouse_pos.x >= canvasPos.x + TRACK_HEADER_WIDTH) {
            float new_time = (mouse_pos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX) / pixelsPerSecond;
            state.currentFrame = std::max(state.video->frameForTime(new_time), 0);
            isScrubbing = true;
        }
        else if (isPlacingClip && placeType == selectedTrackType) {
            float time = (mouse_pos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX) / pixelsPerSecond;
            int frame = state.video->frameForTime(time);
            bool collision = willClipCollide(frame, placeDuration, selectedTrackIdx, selectedTrackType);
            if (placeCb && !collision) {
                placeCb(frame, selectedTrackIdx);
                placeCb = nullptr;
                isPlacingClip = false;
            }
        }
    }

    if (resizeMode != RESIZE_NONE && !isAdjustingFade && ImGui::IsMouseDragging(0)) {
        ImVec2 mouse_pos = io.MousePos;
        float mouse_time = (mouse_pos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX) / pixelsPerSecond;
        resizingTrackIdx = std::max(0, resizingTrackIdx);

        if (resizeMode == RESIZE_LEFT) {
            float newStart = std::max(0.0f, mouse_time);
            float maxStart = (float)(resizeOriginalStart + resizeOriginalDuration) / state.video->getFPS() - 0.1f; // Min 0.1s duration
            newStart = std::min(newStart, maxStart);

            int newStartFrame = state.video->frameForTime(newStart);
            if (selectedTrackType == TrackType::Video) {
                for (auto _clip : state.video->getTracks()[resizingTrackIdx]->getClips()) {
                    auto clip = _clip.second;
                    if (clip == resizingClip) continue;
                    int clipEnd = clip->startFrame + clip->duration; // exclusive

                    if (!(newStartFrame >= clipEnd)) {
                        newStartFrame = clipEnd + 1;
                        break;
                    }
                }
            } else {
                for (auto _clip : state.video->audioTracks[resizingTrackIdx]->getClips()) {
                    auto clip = _clip.second;
                    if (clip == resizingClip) continue;
                    int clipEnd = clip->startFrame + clip->duration; // exclusive

                    if (!(newStartFrame >= clipEnd)) {
                        newStartFrame = clipEnd + 1;
                        break;
                    }
                }
            }
            resizingClip->startFrame = newStartFrame;
            resizingClip->duration = resizeOriginalDuration - (newStartFrame - (float)(resizeOriginalStart));
        } else if (resizeMode == RESIZE_RIGHT) {
            float minEndTime = state.video->timeForFrame(resizingClip->startFrame) + 0.1f; // Min 0.1s duration
            float newEndTime = std::max(minEndTime, mouse_time);
            int newEndFrame = state.video->frameForTime(newEndTime);
            if (selectedTrackType == TrackType::Video) {
                for (auto _clip : state.video->getTracks()[resizingTrackIdx]->getClips()) {
                    auto clip = _clip.second;
                    if (clip == resizingClip || clip->startFrame + clip->duration <= resizingClip->startFrame) continue;
                    int clipStart = clip->startFrame;

                    if (newEndFrame >= clipStart) {
                        newEndFrame = clipStart - 1;
                        break;
                    }
                }
            } else {
                for (auto _clip : state.video->audioTracks[resizingTrackIdx]->getClips()) {
                    auto clip = _clip.second;
                    if (clip == resizingClip || clip->startFrame + clip->duration <= resizingClip->startFrame) continue;
                    int clipStart = clip->startFrame;

                    if (newEndFrame >= clipStart) {
                        newEndFrame = clipStart - 1;
                        break;
                    }
                }
            }
            resizingClip->duration = newEndFrame - resizingClip->startFrame;
        }
    }

    if (isDragging && !isAdjustingFade && resizeMode == RESIZE_NONE && ImGui::IsMouseDragging(0)) {
        if (state.areClipsSelected()) {
            // auto selectedClip = state.getSelectedClip();
            ImVec2 mouse_pos = io.MousePos;

            // float vertical_movement = std::abs(mouse_pos.y - dragStartPos.y);
            // vertical_movement > 20.0f

            fmt::println("DELTA: h {}, s {}, h != s {}", hoveredTrackIdx, selectedTrackIdx, hoveredTrackIdx != selectedTrackIdx);
            if (hoveredTrackIdx != selectedTrackIdx) {
                isMovingBetweenTracks = true;
                ogTrackType = selectedTrackType;
            }
            
            float newStartTime = (mouse_pos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX + dragOffset.x) / pixelsPerSecond;
            int deltaFrame = state.video->frameForTime(newStartTime) - initialStartFrame;
            totalDeltaFrame += deltaFrame;
            int trackQuantity = selectedTrackType == TrackType::Video ? state.video->videoTracks.size() : state.video->audioTracks.size();
            int deltaTrack = std::clamp(
                hoveredTrackIdx - selectedTrackIdx,
                -trackQuantity + 1,
                trackQuantity - 1
            );

            fmt::println("delta-t: {}", deltaTrack);

            bool trackCollision = false;

            int maxVideoTrackIdx = 0;
            int minVideoTrackIdx = state.video->videoTracks.size() - 1;

            int maxAudioTrackIdx = 0;
            int minAudioTrackIdx = state.video->audioTracks.size() - 1;

            bool videoClipSelected = false;
            bool audioClipSelected = false;
            
            for (auto [clipID, selectedClip] : state.getSelectedClips()) {
                if (trackCollision) break;
                int trackIdx = state.video->getClipMap()[clipID];

                TrackType clipType = TrackType::Video;
                int targetTrack = std::clamp(trackIdx + deltaTrack, 0, static_cast<int>(state.video->videoTracks.size()) - 1);
                if (trackIdx < 0) {
                    targetTrack = std::clamp(-(trackIdx + 1) + deltaTrack, 0, static_cast<int>(state.video->audioTracks.size()) - 1);

                    clipType = TrackType::Audio;

                    maxAudioTrackIdx = debug(std::max(maxAudioTrackIdx, -(trackIdx + 1)));
                    minAudioTrackIdx = std::min(minAudioTrackIdx, -(trackIdx + 1));

                    audioClipSelected = true;
                } else {
                    maxVideoTrackIdx = std::max(maxVideoTrackIdx, trackIdx);
                    minVideoTrackIdx = std::min(minVideoTrackIdx, trackIdx);

                    videoClipSelected = true;
                }

                if (isMovingBetweenTracks && targetTrack != selectedTrackIdx && selectedClip) {
                    trackCollision = willClipCollide(selectedClip->startFrame, selectedClip->duration, targetTrack, clipType, { selectedClip->uID });
                }
            }

            // fair warning to anyone reading this code:
            // it is currently 9:45pm on halloween (friday) 2025,
            // and i have spent the past WEEK working on this code
            // to try to get clip multi-select working.
            // it SUCKS and i know that
            // however i am too tired
            // to figure out a better solution.
            // apologies to those who try to understand this code;
            // i have left comments to hopefully aid you
            // (they won't.)

            // to account for
            // a weird edge case for where there are two tracks
            // one audio and one video
            bool isOnSameTracks = videoClipSelected && audioClipSelected &&
                        maxAudioTrackIdx == minAudioTrackIdx &&
                        maxVideoTrackIdx == minVideoTrackIdx &&
                        maxAudioTrackIdx == maxVideoTrackIdx;

            // if there is no video clip selected, set this conditonal to true regardless of anything else
            bool videoCanMove = videoClipSelected ?
                debug(maxVideoTrackIdx + (selectedTrackType == TrackType::Video ? deltaTrack : -deltaTrack)) < state.video->videoTracks.size() &&
                debug(minVideoTrackIdx + (selectedTrackType == TrackType::Video ? deltaTrack : -deltaTrack)) >= 0
            : true;

            // if there is no audio clip selected, set this conditonal to true regardless of anything else
            bool audioCanMove = audioClipSelected ?
                debug(maxAudioTrackIdx + (selectedTrackType == TrackType::Audio ? deltaTrack : -deltaTrack)) < state.video->audioTracks.size() &&
                debug(minAudioTrackIdx + (selectedTrackType == TrackType::Audio ? deltaTrack : -deltaTrack)) >= 0
            : true;

            // i welcome you to
            // TERNARY OPERATOR ABUSE!!!!!!!!!!!!!
            if (
                !trackCollision && isMovingBetweenTracks &&
                ((
                    // if we're on the same tracks, set it to false
                    // so that this conditional gets skipped
                    // and we go to the one that evaluates clips
                    // on the same tracks
                    isOnSameTracks ? false : videoCanMove && audioCanMove
                ) || (
                    // this is most likely to be used for video clips
                    // this code sux regardless though

                    // if we're not on the same tracks, set this conditonal to true regardless of anything else
                    debug(isOnSameTracks) ?
                        debug(maxVideoTrackIdx + deltaTrack) < state.video->videoTracks.size() &&
                        debug(minVideoTrackIdx + deltaTrack) >= 0 &&
                        debug(maxAudioTrackIdx + deltaTrack) < state.video->audioTracks.size() &&
                        debug(minAudioTrackIdx + deltaTrack) >= 0
                    : true
                ))
            ) {
                for (auto [clipID, selectedClip] : state.getSelectedClips()) {
                    int trackIdx = state.video->getClipMap()[clipID];

                    TrackType clipType = TrackType::Video;
                    int targetTrack = trackIdx + (isOnSameTracks ? deltaTrack : (selectedTrackType == TrackType::Video ? deltaTrack : -deltaTrack));
                    if (trackIdx < 0) {
                        targetTrack = -(trackIdx + 1) + (isOnSameTracks ? deltaTrack : (selectedTrackType == TrackType::Audio ? deltaTrack : -deltaTrack));
                        clipType = TrackType::Audio;
                    }
                    targetTrack = std::max(targetTrack, 0);
                    fmt::println("t: {}, d: {}", targetTrack, deltaTrack);
                    if (targetTrack < 0) continue;
                    if (clipType == TrackType::Audio) {
                        state.video->removeAudioClip(trackIdx, std::static_pointer_cast<AudioClip>(selectedClip));
                        state.video->addAudioClip(targetTrack, std::static_pointer_cast<AudioClip>(selectedClip));
                    } else {
                        state.video->removeClip(trackIdx, selectedClip);
                        state.video->addClip(targetTrack, selectedClip);
                    }
                    if (trackIdx < 0) trackIdx = -(trackIdx + 1);
                    if (trackIdx == selectedTrackIdx && clipType == selectedTrackType) {
                        selectedTrackIdx = std::clamp(targetTrack, 0, trackQuantity - 1);
                    }
                    // make sure the clip is still selected
                    state.selectClip(selectedClip);
                }
                if (deltaTrack != 0) {
                    state.addAction(std::make_shared<ChangeClipTrack>(state.selectedClips, deltaTrack, selectedTrackType, isOnSameTracks));
                }
            }

            // check if it collides with another clip
            bool clipCollision = false;
            for (auto [clipID, selectedClip] : state.getSelectedClips()) {
                if (clipCollision) break;
                TrackType clipType = TrackType::Video;
                int trackIdx = state.video->getClipMap()[clipID];
                int targetTrack = trackIdx;
                if (trackIdx < 0) {
                    targetTrack = -(trackIdx + 1);
                    clipType = TrackType::Audio;
                }

                int newStartFrame = selectedClip->startFrame + deltaFrame;
                int newEndFrame = selectedClip->duration + newStartFrame;

                clipCollision = willClipCollide(newStartFrame, selectedClip->duration, targetTrack, clipType, { selectedClip->uID });
            }

            if (!clipCollision) {
                for (auto [trackIdx, selectedClip] : state.getSelectedClips()) {
                    int newStartFrame = selectedClip->startFrame + deltaFrame;
                    selectedClip->startFrame = std::max(newStartFrame, 0);
                }
            }

            initialStartFrame = initialStartFrame + deltaFrame;
        }
    }

    int snapThreshold = 10; // 10 frame threshold to snap

    if (isScrubbing && ImGui::IsMouseDragging(0)) {
        float new_time = (io.MousePos.x - canvasPos.x - TRACK_HEADER_WIDTH + scrollX) / pixelsPerSecond;
        state.currentFrame = state.video->frameForTime(new_time);

        if (selectedTrackType == TrackType::Video) {
            auto clips = state.video->videoTracks[selectedTrackIdx]->getClips();
            for (auto [_, clip] : clips) {
                if (std::abs(state.currentFrame - clip->startFrame) <= snapThreshold) {
                    state.currentFrame = clip->startFrame;
                }
                
                if (std::abs(clip->startFrame + clip->duration - state.currentFrame) <= snapThreshold) {
                    state.currentFrame = clip->startFrame + clip->duration;
                }
            }
        } else if (selectedTrackType == TrackType::Audio) {
            auto clips = state.video->audioTracks[selectedTrackIdx]->getClips();
            for (auto [_, clip] : clips) {
                if (std::abs(state.currentFrame - clip->startFrame) <= snapThreshold) {
                    state.currentFrame = clip->startFrame;
                }
                
                if (std::abs(state.currentFrame - clip->startFrame + clip->duration) <= snapThreshold) {
                    state.currentFrame = clip->startFrame + clip->duration;
                }
            }
        }
    }

    if (state.areClipsSelected()) {
        for (auto [clipID, clip] : state.getSelectedClips()) {
            TrackType clipType = TrackType::Video;
            int trackIdx = state.video->getClipMap()[clipID];
            int targetTrack = trackIdx;
            if (trackIdx < 0) {
                targetTrack = -(trackIdx + 1);
                clipType = TrackType::Audio;
            }

            if (resizeMode != RESIZE_NONE) {
                auto doTheThingL = [&](std::shared_ptr<Clip> _clip) {
                    if (std::abs(clip->startFrame - (_clip->startFrame + _clip->duration)) <= snapThreshold) {
                        clip->startFrame = _clip->startFrame + _clip->duration + 1;
                    }
                };

                auto doTheThingR = [&](std::shared_ptr<Clip> _clip) {
                    if (std::abs(clip->startFrame + clip->duration - _clip->startFrame) <= snapThreshold) {
                        clip->duration = _clip->startFrame - clip->startFrame - 1;
                    }
                };
                switch (resizeMode) {
                    case RESIZE_LEFT:
                        if (std::abs(clip->startFrame - state.currentFrame) <= snapThreshold) { 
                            clip->startFrame = state.currentFrame + 1;
                        }

                        if (clipType == TrackType::Video) {
                            for (auto [_, _clip] : state.video->videoTracks[targetTrack]->getClips()) {
                                if (clip == _clip) continue;
                                doTheThingL(_clip);
                            }
                        } else {
                            for (auto [_, _clip] : state.video->audioTracks[targetTrack]->getClips()) {
                                if (clip == _clip) continue;
                                doTheThingL(_clip);
                            }
                        }
                        break;
                    case RESIZE_RIGHT:
                        if (std::abs(clip->startFrame + clip->duration - state.currentFrame) <= snapThreshold) {
                            clip->duration = state.currentFrame - clip->startFrame - 1;
                        }

                        if (clipType == TrackType::Video) {
                            for (auto [_, _clip] : state.video->videoTracks[targetTrack]->getClips()) {
                                if (clip == _clip) continue;
                                doTheThingR(_clip);
                            }
                        } else {
                            for (auto [_, _clip] : state.video->audioTracks[targetTrack]->getClips()) {
                                if (clip == _clip) continue;
                                doTheThingR(_clip);
                            }
                        }
                        break;
                    default: // go away compiler this is unreachable anyways...
                        fmt::println("this should be unreachable what");
                        break;
                }
            } else if (isDragging && !isAdjustingFade) {
                // TODO: apply to all selected clips
                // by applying the delta-start-frame 
                // to all selected clips
                if (std::abs(clip->startFrame - state.currentFrame) <= snapThreshold) { 
                    clip->startFrame = state.currentFrame + 1;
                }

                if (std::abs(clip->startFrame + clip->duration - state.currentFrame) <= snapThreshold) {
                    clip->startFrame = state.currentFrame - clip->duration + 1;
                }

                auto doTheThingDrag = [&](std::shared_ptr<Clip> _clip) {
                    if (std::abs(_clip->startFrame + _clip->duration - clip->startFrame) <= snapThreshold) {
                        clip->startFrame = _clip->startFrame + _clip->duration + 1;
                    }
                    
                    if (std::abs(clip->startFrame + clip->duration - _clip->startFrame) <= snapThreshold) {
                        clip->startFrame = _clip->startFrame - clip->duration + 1;
                    }
                };

                if (clipType == TrackType::Video) {
                    for (auto [_, _clip] : state.video->videoTracks[targetTrack]->getClips()) {
                        if (clip == _clip) continue;
                        doTheThingDrag(_clip);
                    }
                } else {
                    for (auto [_, _clip] : state.video->audioTracks[targetTrack]->getClips()) {
                        if (clip == _clip) continue;
                        doTheThingDrag(_clip);
                    }
                }
            }
        }
    }

    state.video->recalculateFrameCount();

    if (ImGui::IsMouseReleased(0)) {
        if (isDragging && !isAdjustingFade) {
            if (resizeMode == RESIZE_NONE && totalDeltaFrame != 0) {
                state.addAction(std::make_shared<MoveClip>(state.selectedClips, totalDeltaFrame));
            }
        }
        if (resizeMode != RESIZE_NONE) {
            state.addAction(std::make_shared<ResizeClip>(resizingClip, resizeOriginalStart, resizeOriginalDuration));
        }
        totalDeltaFrame = 0;
        isDragging = false;
        isAdjustingFade = false;
        fadeAdjustID = "";
        isScrubbing = false;
        isMovingBetweenTracks = false;
        resizingClip = nullptr;
        // draggingTrackIdx = -1;
        originalTrackId = -1;
        initialStartFrame = -1;
        resizeMode = RESIZE_NONE;
    }
}

void Timeline::scrollToTime(float time, bool center) {
    float target_pixel_pos = time * pixelsPerSecond;
    float viewport_width = canvasSize.x - TRACK_HEADER_WIDTH;

    if (center) {
        scrollX = target_pixel_pos - viewport_width * 0.5f;
    } else {
        scrollX = target_pixel_pos;
    }

    // Clamp scroll
    float max_scroll = std::max(0.0f, timelineLength * pixelsPerSecond - viewport_width);
    scrollX = std::max(0.0f, std::min(scrollX, max_scroll));
}
